from collections import defaultdict 

"""
ðŸ’Ž Exercise-1: Two Sum
Write a function "two_sum(nums: list, target: int) -> tuple" that takes a list of integers
and a target integer. It should return a tuple of two indices whose elements add up to the target.
Assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
two_sum([2, 7, 11, 15], 9) -> (0, 1)
"""

def two_sum(nums: list, target: int) -> tuple:
    '''
    Comment to mentor: 
    A bug in 4th test case. A test case has two possible 
    solutions. So, below solution should work, but it doesn't. 

    seen = {}
    for index, val in enumerate(nums): 
        if (target-val) in seen: 
            return (seen[target-val], index) 
        seen[val] = index 
    return (None, None) 
    
    '''
    seen = {}
    for index, val in enumerate(nums): 
        if (target-val) in seen: 
            res = (seen[target-val], index) 
        seen[val] = index 
    return res 

"""
ðŸ’Ž Exercise-2: Isomorphic Strings
Write a function "is_isomorphic(s: str, t: str) -> bool" that takes two strings s and t
and determines if they are isomorphic. Two strings s and t are isomorphic if the characters
in s can be replaced to get t, and all characters in s map to exactly one character in t and vice versa.

Example:
is_isomorphic('egg', 'add') -> True
"""

def is_isomorphic(s: str, t: str) -> bool:
    '''
    Comment to mentor: 
    Test case 5 should evaluate to True, not False?

    '''
    d1, d2 = {}, {}

    for c1, c2 in zip(s,t):
        if c1 not in d1: 
            d1[c1] = c2 
        if c2 not in d2: 
            d2[c2] = c1 
        
        if d1[c1] != c2 or d2[c2] != c1: 
            return False 
    return True 



"""
ðŸ’Ž Exercise-3: Check Alien Dictionary
Write a function "is_alien_sorted(words: list, order: str) -> bool" that checks if words
are sorted lexicographicaly according to a new character order provided in the string order.

Example:
is_alien_sorted(["hello","leetcode"], "hlabcdefgijkmnopqrstuvwxyz") -> True
"""

def is_alien_sorted(words: list, order: str) -> bool:
    orderIndex = { w:i for i,w in enumerate(order) }

    for i in range(len(words)-1): 
        w1, w2 = words[i], words[i+1]

        for j in range(len(w1)): 
            if j == len(w2): 
                return False 
            if w1[j] != w2[j]: 
                if orderIndex[w1[j]] > orderIndex[w2[j]]: 
                    return False 
                break 
    return True 


"""
ðŸ’Ž Exercise-4: Longest Substring Without Repeating Characters
Write a function "length_of_longest_substring(s: str) -> int" that takes a string s,
and returns the length of the longest substring without repeating characters.

Example:
length_of_longest_substring('abcabcbb') -> 3
"""

def length_of_longest_substring(s: str) -> int:
    counts = {}
    curr_max = 0 
    j = 0 

    for i in range(len(s)): 
        counts[s[i]] = counts.get(s[i], 0) + 1 

        while counts[s[i]] > 1: 
            counts[s[j]] -= 1
            if counts[s[j]] == 0: 
                del counts[s[j]]
            j += 1
        curr_max = max(curr_max, i-j+1)
    return curr_max 


"""
ðŸ’Ž Exercise-5: Group Shifted Strings
Write a function "group_shifted(strings: list) -> list" that takes a
list of lowercase strings and groups all strings that are generated by shifting some letters
of another string circularly. Return a list of groups, each group is a list of strings.
Groups and strings within a group can be in any order.

Example:
group_shifted(["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]) -> [["abc","bcd"],["acef"],["xyz"],["az","ba"],["a","z"]]
"""

def group_shifted(strings: list) -> list:
    '''
    Comment to mentor: 
    Test case 1 is incorrect? 
    ["xyz"] should be grouped with ["abc","bcd"] ? 
    
    '''
    res = defaultdict(list)

    for w in strings: 
        if len(w) == 1: 
            res[(-99,)].append(w)
            continue 

        offsets = []
        for i in range(1, len(w)):
            delta = (ord(w[i]) - ord(w[i-1])) % 26 
            offsets.append(delta)
        res[tuple(offsets)].append(w)
    return list(res.values())
